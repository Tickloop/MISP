# -*- coding: utf-8 -*-
"""FNNv2.ipynb

Automatically generated by Colaboratory.
Some superfluous code has been removed.

Original file is located at
    https://colab.research.google.com/drive/1LMemrtod9qnBw4q3J1djNsMawYHIIvYE
"""

# Commented out IPython magic to ensure Python compatibility.
from collections import Counter

#Basic PyTorch setup
import torch
import torch.nn as nn

class MLP(nn.Module):
    def __init__(self, input_dim=13, hid_dim=100, output_dim=1):
        # initialze the superclass
        super(MLP, self).__init__()
        # this will create a linear layer with input_dim x hid_dim parameters
        # in addition to a bias unit with hid_dim parameters
        self.lin1 = nn.Linear(input_dim, hid_dim)

        # adding another hidden layer in the mix
        self.lin2 = nn.Linear(hid_dim, hid_dim)

        # same thing here except hid_dim x output_dim
        self.lin3 = nn.Linear(hid_dim, output_dim)
    
    def forward(self, x):
        x = self.lin1(x)  # linear combination of inputs
        x = torch.sigmoid(x) # then through sigmoid - output of first layer
        x = self.lin2(x) # linear combination of hidden units
        x = torch.sigmoid(x)
        x = self.lin3(x)
        x = torch.sigmoid(x)
        return x

class ModelIndexer:
  def __init__(self, model, indexer):
    self.model = model
    self.indexer = indexer

  def get_model(self):
    return self.model
  
  def get_indexer(self):
    return self.indexer